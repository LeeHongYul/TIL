오늘 배운 내용

2차원 배열에 대해 공부했다.

var dots = [[Int]]() //2차원 배열 선업 하는 방법

dots = [[1, 4], [9, 2], [3, 8], [11, 6]]

//2차원 배열안에 [x1,x2]에 있는 각 각 x1,와 x2 에 접근할려며 따로 함수를 만들어서 (ex getInclination) dot1[0], dot1[0] 접근을 했다.

private func getInclination(_ dot1: [Int], _ dot2: [Int]) -> Double { Double(dot1[1] - dot2[1]) / Double(dot1[0] - dot2[0]) }

print(getInclination(dots[0], dots[2]))
//[1,4] [3,8]에서 3 - 1 ,8 - 4 출력 하는 코드

//다른 방법은 let을 빼서 계산하는 케이스도 있었음
    let a = dots[0]
    let b = dots[1]
    let c = dots[2]
    let d = dots[3]

    func degree(_ a: [Int], _ b: [Int]) -> Float {
        let (x0, y0) = (a[0], a[1])
        let (x1, y1) = (b[0], b[1])
        return Float(y1 - y0) / Float(x1 - x0)
    }

Closures

문법 최적화

1. 파라미터 형식와 리턴 형식 생략 가능
2. 파라미터 이름, in 생략하고 shorthand argument 으로 대체
3. 단일 리턴문이라면 생략
4. 클로저가 마지막 파라미터라면 trailing closures로 작성한다
5. 괄호안에 파라미터 레이블 생략 후 괄호 삭제

Tuple Decompositon: 투플에 저장된 멤버를 개별 상수나 개별 변수에 저장하는 방법
Tuple Matching: 
if문으로 사용해도 되지만 switch문으로 했을때 조합할수 있는게 많음(let, where), 가독성도 좋음


어려웠던 내용
2차원 배열의 x1,x2 원소에 대한 접근 방법을 몰랐었다.


부족한 내용/ 해결 못한 내용
간단하게 AlamoFire,Realm,CoreData 개념에 대하여 공부해봤다. 아직까지 각 특징, 어떤 앱에 사용해야하는지는 부족.
Capturing Values, Autoclosure

느낀점
Closures에 대해 공부를 했다, 다양한 방법으로 사용할 수 있는 클로져 공부가 더 필요해 보이고, 매우 중요해 보인다. 클로저의 각 특징으 이해 못하면 코드를 간단하게 못 만들고 클로져를 사용한 코드도 이해를 못할수도있다 그러므로 매우 중요하다고 느꼈다
        
      
