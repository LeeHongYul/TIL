### 오늘의 공부

저는 현재 개인 프로젝트를 진행하면서 코드를 개선하고 기본기를 더 다지기 위해 필요한 부분을 공부하고 있다. 이를 위해 문법을 다시 한 번 복습하고 있다.<br>

### 상속
init 메소드에 기본값을 지정하는 것은 가능하다.<br>
상속 시에는 별도로 정의하지 않아도 부모 클래스의 기본 초기화 구문이 내장되어 있기 때문에, 오버라이딩한 init 메소드가 필요하다.<br>
그리고 초기화 구문을 오버라이딩하면 부모 클래스에서 정의한 초기화 구문이 실행되지 않는다. 프로퍼티가 초기화되지 못하는 상황은 오류가 발생하므로, 이를 방지하기 위해 부모 클래스에서 정의된 구문을
내부적으로 호출해야 하며, 이때 super.init()을 사용한다.

```swift
override init() {
    super.init()
}
```

클래스는 참조 타입이기 때문에, mutating 키워드 없이도 프로퍼티를 자유롭게 수정할 수 있다.<br>
하지만 구조체나 열거형은 값 타입이므로, 프로토콜의 메소드에 mutating 키워드가 없다면 값을 변경할 수 없다.<br>

### 프로토콜
프로토콜의 메소드와 클래스 메소드의 차이점은 중괄호 블록의 유무이다. 프로토콜에서 메소드를 선언할 때는 중괄호 블록이 없었다.<br>
내부 매개변수의 경우에는 프로토콜을 그대로 따르지 않고 필요에 따라 변형하여 사용할 수 있다. 내부 매개변수의 이름이나 타입 등을 프로토콜의 메소드에서 정의한 것과 다르게 지정할 수 있다.<br>

프로토콜에 선언된 초기화 메소드는 기본 제공 여부와 상관없이 모두 구현되어야 한다. 클래스에서 초기화 메소드를 구현할 때는 required 키워드를 붙여야 한다.<br>

프로토콜의 확장에서는 저장 프로퍼티를 직접적으로 정의할 수는 없다. 따라서, 만약 프로토콜에 정의된 프로퍼티를 익스텐션에서 구현해야 한다면, 연산 프로퍼티로 구현해야 한다.<br>

```swift
protocol MyProtocol {
    var myProperty: Int { get set }
}

extension MyProtocol {
    var myProperty: Int {
        get {
            // 프로퍼티의 get 구현
            // ...
        }
        set {
            // 프로퍼티의 set 구현
            // ...
        }
    }
}
```

### Error
오류 반환과 오류 던지기의 차이점은 다음과 같다. 오류 반환은 함수의 반환 타입과 일치해야 하지만, 오류 던지기는 일치하지 않아도 된다.<br>
오류 던지기는 실행 흐름 중간에 오류 객체를 생성하여 다른 실행 흐름으로 제어를 이동시키는 것을 의미한다.<br>

### 오버로딩
오버로딩을 할 때는 함수 이름, 파라미터 (수, 타입, 아규먼트 레이블), 리턴 타입을 모두 고려하여 구분한다.<br>
이들 요소를 조합하여 서로 다른 시그니처를 가진 여러 함수를 선언할 수 있다.<br>

